}
mf_title(title)
if (scale == TRUE){
mf_scale(size = 20, pos = "bottomright", lwd = 1.2, cex = 1, col = "#383838", unit = "km")
}
mf_credits(
txt = credits,
pos = "bottomleft",
col = "#1a2640",
cex = 0.8,
font = 3,
bg = "#ffffff30"
)
if(note != ""){
mf_annotation(
x = c(885000, 6435000),
txt = note,
pos = "bottomleft", cex = 1.2, font = 2,
halo = TRUE, s = 1.5
)
}
}
template("Template cartographique", "maps/template.png", note = "Département de\nl'Isère (38)")
mf_map(communes, col = col, border = "white", lwd = 0.5, add = TRUE)
library(sf)
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
isere = st_union(communes)
template = function(title, file, note = "", basemap = TRUE, scale = TRUE){
mf_export(
communes,
export = "png",
width = 1000,
filename = file,
res = 96,
theme = theme,
expandBB = c(-.02,0,-.02,0)
)
if (basemap == TRUE){
mf_shadow(x = communes, col = "grey50", cex = 1, add = TRUE)
mf_map(communes, col ="#CCCCCC", border = "white", lwd = 0.5, add = TRUE)
}
mf_title(title)
if (scale == TRUE){
mf_scale(size = 20, pos = "bottomright", lwd = 1.2, cex = 1, col = "#383838", unit = "km")
}
mf_credits(
txt = credits,
pos = "bottomleft",
col = "#1a2640",
cex = 0.8,
font = 3,
bg = "#ffffff30"
)
if(note != ""){
mf_annotation(
x = c(885000, 6435000),
txt = note,
pos = "bottomleft", cex = 1.2, font = 2,
halo = TRUE, s = 1.5
)
}
}
template("Template cartographique", "maps/template.png", note = "Département de\nl'Isère (38)")
mf_map(communes, col = col, border = "white", lwd = 0.5, add = TRUE)
dev.off()
dotdensitymap <- function(x, var, onedot = 1, radius = 1){
x <- x[,c("id",var,"geometry")]
x[,"v"] <- round(x[,var] %>% st_drop_geometry() /onedot,0)
dots <- st_sample(x, x$v, type = "random", exact = TRUE)
circles <- st_buffer(dots, dist = radius)
return (circles)
}
onedot = 500
dots = dotdensitymap(x = communes, var = "pop2018", onedot = onedot, radius = 300)
template("Carte par points", "maps/dotdensity.png", note = paste0("Un point =\n",onedot," habitants"))
mf_map(dots, col = col, border = "#520a2c", lwd = 0.5, add = TRUE)
dev.off()
if(!file.exists("files/grid.gpkg")){
grid = st_make_grid(communes, cellsize = 1000, square = TRUE)
grid = st_sf(id = c(1:length(grid)), geometry = grid)
ids = communes[,"id"] %>% st_drop_geometry()
ctr = st_centroid(grid)
for(i in 1:nrow(grid)){
x = st_within(x = ctr[i,], y = communes, sparse = TRUE, prepared = TRUE)
id = ids[unlist(x),][1]
if (length(id) == 0){id = NA}
grid[i,"id"] = id
}
grid <- grid[!is.na(grid$id),]
for(i in 1:nrow(grid)){
id = as.character(grid[i,"id"])[1]
popAll = as.numeric(communes[communes$id == id,"pop2018"] %>% st_drop_geometry())
count = nrow(grid[grid$id == id,])
grid[i,"pop"] = popAll / count
}
st_write(grid,"files/grid.gpkg", delete_layer=TRUE)
} else {
grid =
st_read("files/grid.gpkg")
}
template("Points Bertin (grosso modo)", "maps/pointsbertin.png")
mf_map(communes, col = "#CCCCCC", border = "white", lwd = 0.5, add = FALSE)
mf_map(grid, var = "pop", col = col, border = "#520a2c", type = "prop",
inches = 0.07, leg_title_cex = 1.2, leg_val_cex	= 0.8,
leg_title = "Nombre d'habitants, 2018")
dev.off()
template("Symboles proportionnels (mapsf)", "maps/prop2.png")
mf_map(communes, var = "pop2018", col = col, border = "#6b4266", type = "prop",
inches = 0.8, leg_title_cex = 1.2, leg_val_cex	= 0.8, symbol = "square",
leg_title = "Nombre d'habitants, 2018")
dev.off()
template("Symboles proportionnels (mapsf)", "maps/prop.png")
mf_map(communes, var = "pop2018", col = col, border = "#6b4266", type = "prop",
inches = 0.8, leg_title_cex = 1.2, leg_val_cex	= 0.8,
leg_title = "Nombre d'habitants, 2018")
dev.off()
dots = communes
st_geometry(dots) <- st_centroid(sf::st_geometry(dots),of_largest_polygon = TRUE)
dots <- data.frame(dots$id, dots["pop2018"], st_coordinates(dots))
dots = dots[,c("dots.id","X","Y","pop2018")]
colnames(dots) <- c("id","x","y","v")
dots <- dots[!is.na(dots$v),]
knitr::kable(dots[c(0:5),], row.names = F, digits = 1)
library("packcircles")
k = 500 # pour ajuster la taille des cercles
itermax = 10 # nombre d'iterations
dat.init <- dots[,c("x","y","v")]
dat.init$v <- sqrt(dat.init$v * k)
simulation <- circleRepelLayout(x = dat.init, xysizecols = 1:3,
wrap = FALSE, sizetype = "radius",
maxiter = itermax, weights =1)$layout
knitr::kable(simulation[c(0:5),], row.names = F, digits = 1)
circles <- st_buffer(sf::st_as_sf(simulation, coords =c('x', 'y'),
crs = sf::st_crs(communes)), dist = simulation$radius)
circles$v = dots$v
template("Dorling (packcircles)", "maps/dorling1.png", scale = FALSE)
mf_map(isere, col = "#CCCCCC", border = "white", lwd = 0.5, add = TRUE)
mf_map(circles,col = col, border = "#6b4266", lwd = 0.5, add = TRUE)
dev.off()
library(cartogram)
Dorling = cartogram_dorling(communes, "pop2018", k = 1.8)
template("Dorling (cartogram)", "maps/dorling2.png", scale = FALSE)
mf_map(isere, col = "#CCCCCC", border = "white", lwd = 0.5, add = TRUE)
mf_map(Dorling, col = col, border = "#6b4266", lwd = 0.5, add = TRUE)
dev.off()
Olson <- cartogram_ncont(communes, "pop2018", k = 1, inplace = TRUE)
template("Olson (cartogram)", "maps/olson.png", basemap = FALSE, scale = FALSE)
mf_map(isere, col = "#CCCCCC30", border = "white", lwd = 0.5, add = TRUE)
mf_map(Olson, col = col, border = "#6b4266", lwd = 0.5, add = TRUE)
dev.off()
Dougenik <- cartogram_cont(communes, "pop2018", prepare = "none", itermax = 10, maxSizeError = 1.15)
sumarea = sum(as.numeric(st_area(Dougenik)))
sumpop = sum(Dougenik$pop2018)
Dougenik$error = (as.numeric(st_area(Dougenik)) /  sumarea) / (Dougenik$pop2018 / sumpop) * 100
summary(Dougenik$error)
bks = c(min(Dougenik$error),70,80,90,100,110,120,max(Dougenik$error))
cols = c("#d53e4f", "#f46d43","#fdae61","#fee08b","#e6f598","#abdda4", "#66c2a5")
template("Dougenik (cartogram)", "maps/dougenik.png", basemap = FALSE, scale = FALSE)
mf_map(x = Dougenik, type = "choro",var = "error", pal = cols, breaks = bks, border = "#6b4266", lwd = 0.5, add = TRUE)
dev.off()
library(cartogramR)
precarto <- precartogramR(communes, method = "GastnerSeguyMore")
summary(precarto)
GastnerSeguy <- cartogramR(communes, count="pop2018", method="GastnerSeguyMore", options=list(L=256, grid=TRUE, maxit = 5))
grid <- make_layer(GastnerSeguy, type = c("final_graticule"))
template("Gastner, Seguy & More", "maps/gastnerseguy.png", basemap = FALSE, scale = FALSE)
mf_map(GastnerSeguy$cartogram, col = col, border = "white", lwd = 1, add = TRUE)
mf_map(grid, col = NA, border = "#6b4266", lwd = 0.05, add = TRUE)
dev.off()
table = cbind(GastnerSeguy$initial_data[,c("id","pop2018")] %>% st_drop_geometry(),
orig_area = GastnerSeguy$orig_area,
final_area = GastnerSeguy$final_area,
errors = residuals(GastnerSeguy, type = "relative error")*100
)
knitr::kable(table[c(0:10),], row.names = F, digits = 1)
st_write(as.sf(GastnerSeguy),"files/GastnerSeguy.gpkg", delete_layer=TRUE)
dotcartogram = function(x,var,itermax,onedot,radius){
crs = sf::st_crs(x)
coords <- st_coordinates(st_centroid(sf::st_geometry(x),of_largest_polygon = TRUE))
x <- x[c("id",var)] %>% st_drop_geometry()
x <- data.frame(x, coords)
colnames(x) <- c("id","v","x","y")
x$v <- round(x$v/onedot,0)
x <- x[x$v > 0,]
dots <- x[x$v == 1,c("x","y","v")]
rest <-  x[x$v  > 1,c("x","y","v")]
nb <- nrow(rest)
for (i in 1:nb){
new <- rest[i,]
new$v <- 1
for (j in 1:rest$v[i]){ dots <- rbind(dots,new)}
}
dots$x <- jitter(dots$x)
dots$y <- jitter(dots$y)
dots$v <- radius
simulation <- circleRepelLayout(x = dots, xysizecols = 1:3,
wrap = FALSE, sizetype = "radius",
maxiter = itermax, weights =1)$layout
circles <- st_buffer(sf::st_as_sf(simulation, coords =c('x', 'y'),
crs = crs), dist = radius)
return(circles)
}
onedot = 1000
dc = dotcartogram(x = communes, var = "pop2018", itermax = 120,
onedot = onedot, radius = 600)
template("Dots Cartogram", "maps/dotcartogram.png", note = paste0("Un point =\n",onedot," personnes"), scale = FALSE)
mf_map(isere, col = "#CCCCCC", border = "white", lwd = 0.5, add = TRUE)
mf_map(dc, col = col, border = "#6b4266", lwd = 0.8, add = TRUE)
dev.off()
cartogram = st_read("files/GastnerSeguy.gpkg")
grid = st_make_grid(cartogram, cellsize = 2000, square = FALSE)
grid = st_sf(id = rep("",length(grid)), geometry = grid)
ctr = st_centroid(grid)
ids = cartogram[,"id"] %>% st_drop_geometry()
for(i in 1:nrow(grid)){
x = st_within(x = ctr[i,], y = cartogram, sparse = TRUE, prepared = TRUE)
id = ids[unlist(x),][1]
if (length(id) == 0){id = NA}
grid[i,"id"] = id
}
grid <- grid[!is.na(grid$id),]
gridcartogram <- aggregate(x = grid,
by = list(grid$id),
FUN = min)
varmax = sum(cartogram$pop2018)
nbcell = nrow(grid)
valcell = round(varmax / nbcell)
template("Template cartographique", "maps/hexcartogram.png", note = paste0("Un hexagone ≈\n",valcell," habitants"),basemap = FALSE, scale = FALSE)
mf_shadow(x = grid, col = "grey50", cex = 1, add = TRUE)
mf_map(grid, col = col, border = "white", lwd = 0.5, add = TRUE)
mf_map(gridcartogram, col = NA, border = "#6b4266", lwd = 1, add = TRUE)
dev.off()
library(recmap)
coords <- st_centroid(communes)
coords <- st_transform(coords, crs="+proj=longlat +datum=WGS84 +ellps=WGS84")
coords <- st_coordinates(coords)
coords
sfc_as_cols <- function(x, geometry, names = c("X","Y")) {
if (missing(geometry)) {
geometry <- sf::st_geometry(x)
} else {
geometry <- rlang::eval_tidy(enquo(geometry), x)
}
stopifnot(inherits(x,"sf") && inherits(geometry,"sfc_POINT"))
ret <- sf::st_coordinates(geometry)
ret <- tibble::as_tibble(ret)
stopifnot(length(names) == ncol(ret))
x <- x[ , !names(x) %in% names]
ret <- setNames(ret,names)
dplyr::bind_cols(x,ret)
}
checkerboard
map <- checkerboard
map
rec_cartogram <- data.frame (x= coords$x,
y=coords$y,
# make the rectangles overlapping by correcting lines of longitude distance
dx = sqrt(coords$pop2018) / 90 / abs((0.65 * 60 * cos(coords$y*pi/180))),
dy = sqrt(coords$pop2018) / 90 / (0.65 * 60),
z = sqrt(coords$pop2018),
name = coords$id)
coords$x
coords
head(coords)
rec_cartogram <- data.frame (x= coords$X,
y=coords$Y,
# make the rectangles overlapping by correcting lines of longitude distance
dx = sqrt(coords$pop2018) / 90 / abs((0.65 * 60 * cos(coords$y*pi/180))),
dy = sqrt(coords$pop2018) / 90 / (0.65 * 60),
z = sqrt(coords$pop2018),
name = coords$id)
coords$pop2018
library(recmap)
sfc_as_cols <- function(x, geometry, names = c("x","y")) {
if (missing(geometry)) {
geometry <- sf::st_geometry(x)
} else {
geometry <- rlang::eval_tidy(enquo(geometry), x)
}
stopifnot(inherits(x,"sf") && inherits(geometry,"sfc_POINT"))
ret <- sf::st_coordinates(geometry)
ret <- tibble::as_tibble(ret)
stopifnot(length(names) == ncol(ret))
x <- x[ , !names(x) %in% names]
ret <- setNames(ret,names)
dplyr::bind_cols(x,ret)
}
coords <- st_centroid(communes)
library(sf)
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
isere = st_union(communes)
coords <- st_centroid(communes)
coords <- st_transform(coords, crs="+proj=longlat +datum=WGS84 +ellps=WGS84")
coords
df_recmap <- sfc_as_cols(coords)
df_recmap
rec_cartogram <- data.frame (x= df_recmap$x,
y=df_recmap$y,
# make the rectangles overlapping by correcting lines of longitude distance
dx = sqrt(df_recmap$pop2018) / 90 / abs((0.65 * 60 * cos(df_recmap$y*pi/180))),
dy = sqrt(df_recmap$pop2018) / 90 / (0.65 * 60),
z = sqrt(df_recmap$pop2018),
name = df_recmap$id)
library(sf)
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
isere = st_union(communes)
bb <- st_bbox(communes)
st_voronoi(communes, bb)
library(sf)
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
isere = st_union(communes)
bb <- st_bbox(communes)
test = st_voronoi(communes, bb)
bb = st_as_sfc(st_bbox(communes))
test = st_voronoi(communes, bb)
class(test)
plot(st_geometry(test))
library(sf)
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
isere = st_union(communes)
bb <- st_bbox(communes)
bb = st_as_sfc(st_bbox(communes))
library(sf)
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
isere = st_union(communes)
bb = st_as_sfc(st_bbox(communes))
test = st_voronoi(communes, bb)
plot(st_geometry(test))
class(test)
View(test)
plot(st_geometry(test), lwd = 0.1, col ="NA")
test = st_voronoi(st_centroind(communes), bb)
test = st_voronoi(st_centroid(communes), bb)
plot(st_geometry(test), lwd = 0.1, col ="NA")
plot(st_geometry(test))
library(sf)
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
isere = st_union(communes)
bb = st_as_sfc(st_bbox(communes))
test = st_voronoi(st_centroid(communes), bb)
plot(st_geometry(test))
test = st_voronoi(st_centroid(communes))
st_centroid(communes)
ctr = st_centroid(communes)
ctr
test = st_voronoi(ctr, bb)
plot(st_geometry(test))
plot(st_geometry(test), col = "red")
plot(st_geometry(test), col = NA)
test = st_voronoi(ctr)
plot(st_geometry(test), col = NA)
plot(st_geo)
set.seed(100)
df <- data.frame(ID = 1:10, X = sample(1:10, 10), Y = sample(1:10, 10))
df
d <- st_geometry(st_as_sf(df,coords = c("X", "Y")))
d
d <- st_union(d)
d
hull <- st_convex_hull(d)
hull
plot(hull)
plot(d, add = TRUE)
v <- st_voronoi(d)
v
View(d)
test = st_voronoi(st_geometry(ctr), bb)
plot(st_geometry(test), col = "red")
ctr = st_centroid(st_geometry(communes))
bb = st_as_sfc(st_bbox(communes))
ctr = st_centroid(st_geometry(communes))
test = st_voronoi(ctr, bb)
plot(st_geometry(test), col = "red")
plot(st_geometry(test))
plot(st_geometry(isere))
plot(st_geometry(test), add= T)
plot(st_geometry(test), add= T, col = NA, border = "red")
plot(st_geometry(isere))
plot(st_geometry(test), add= T, col = NA, border = "red")
v = st_voronoi(do.call(ctr, bb))
v = st_sfc(st_voronoi(communes, st_sfc(st_bbox(communes))))
v = st_sfc(st_voronoi(communes, st_sfc(st_bbox(communes)))
v = st_sfc(st_voronoi(communes, st_sfc(st_bbox(communes))
v = st_sfc(st_voronoi(communes, st_sfc(st_bbox(communes))
v = st_sfc(st_voronoi(communes, st_sfc(st_bbox(communes))))
v = st_sfc(st_voronoi(communes, st_sfc(st_bbox(communes))))
v = st_sfc(st_voronoi(st_geometry(communes), st_sfc(st_bbox(communes))))
st_voronoi(st_geometry(communes), st_sfc(st_bbox(communes)))
st_voronoi(st_centroid(st_geometry(communes)), st_sfc(st_bbox(communes)))
st_voronoi(st_centroid(st_geometry(communes)), st_sfc(st_bbox(communes)))
x = st_centroid(st_geometry(communes)
x = st_centroid(st_geometry(communes))
x = st_centroid(st_geometry(communes))
x
bb = st_as_sfc(st_bbox(communes))
bb
st_voronoi(x,bb)
st_sfc(st_voronoi(x,bb))
x = st_sfc(st_voronoi(x,bb))
plot(st_geometry(x))
st_voronoi(x, bb, dTolerance = 0, bOnlyEdges = FALSE)
x = st_voronoi(x, bb, dTolerance = 0, bOnlyEdges = FALSE)
View(x)
plot(st_geometry(x))
x = st_voronoi(x, NULL, dTolerance = 0, bOnlyEdges = FALSE)
plot(x)
plot(x, col = NA)
ctr <- st_centroid(communes)
st_voronoi(x = st_union(ctr))
x <- st_voronoi(x = st_union(ctr))
plot(x)
v <- st_intersection(st_cast(v), st_union(communes))
st_union(ctr)
v
ctr <- st_centroid(communes)
ctr <- st_centroid(st_geometry(communes))
v <- st_voronoi(x = st_union(ctr))
plot(v)
v = st_voronoi(x, NULL, dTolerance = 0, bOnlyEdges = FALSE)
v <- st_intersection(st_cast(v), st_union(communes))
v
ctr <- st_centroid(st_geometry(communes))
v <- st_intersection(st_cast(v), st_union(communes))
c <- st_centroid(st_geometry(communes))
v <- st_intersection(st_cast(v), st_union(communes))
v <- st_join(x = st_sf(v), y = c, join=st_intersects)
c <- st_centroid(st_geometry(communes))
v <- st_intersection(st_cast(v), st_union(communes))
v <- st_join(x = st_sf(v), y = c, join=st_intersects)
c <- st_centroid(communes)
v <- st_intersection(st_cast(v), st_union(communes))
v <- st_join(x = st_sf(v), y = c, join=st_intersects)
v <- st_cast(v, "MULTIPOLYGON")
plot(st_geometry(v), col='lightblue')
class(v)
View(v)
library(sf)
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
isere = st_union(communes)
c <- st_centroid(communes)
v <- st_intersection(st_cast(v), st_union(communes))
v <- st_intersection(st_cast(c), st_union(communes))
v <- st_join(x = st_sf(v), y = c, join=st_intersects)
v <- st_cast(v, "MULTIPOLYGON")
c <- st_centroid(st_geometry(communes))
v <- st_intersection(st_cast(c), st_union(communes))
v <- st_join(x = st_sf(v), y = c, join=st_intersects)
library(sf)
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
isere = st_union(communes)
c <- st_centroid(communes)
v <- st_intersection(st_cast(c), st_union(communes))
v
c <- st_centroid(communes)
v <- st_voronoi(x = st_union(c))
v <- st_intersection(st_cast(c), st_union(communes))
v <- st_join(x = st_sf(v), y = c, join=st_intersects)
v <- st_cast(v, "MULTIPOLYGON")
c <- st_centroid(st_geometry(communes))
v <- st_voronoi(x = st_union(c))
v <- st_intersection(st_cast(c), st_union(communes))
v <- st_join(x = st_sf(v), y = c, join=st_intersects)
c <- st_centroid(communes)
v <- st_voronoi(x = st_union(c))
library(sf)
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
isere = st_union(communes)
c <- st_centroid(communes)
v <- st_voronoi(x = st_union(c))
v <- st_intersection(st_cast(v), st_union(communes))
v <- st_join(x = st_sf(v), y = c, join=st_intersects)
v <- st_cast(v, "MULTIPOLYGON")
