theme = theme,
expandBB = c(-.02,0,-.02,0)
)
if (basemap == TRUE){
mf_shadow(x = communes, col = "grey50", cex = 1, add = TRUE)
mf_map(communes, col ="#CCCCCC", border = "white", lwd = 0.5, add = TRUE)
}
mf_title(title)
if (scale == TRUE){
mf_scale(size = 20, pos = "bottomright", lwd = 1.2, cex = 1, col = "#383838", unit = "km")
}
mf_credits(
txt = credits,
pos = "bottomleft",
col = "#1a2640",
cex = 0.8,
font = 3,
bg = "#ffffff30"
)
if(note != ""){
mf_annotation(
x = c(885000, 6435000),
txt = note,
pos = "bottomleft", cex = 1.2, font = 2,
halo = TRUE, s = 1.5
)
}
}
template("Template cartographique", "maps/test.png", note = paste0("Un hexagone â‰ˆ\n",valcell," habitants"),basemap = FALSE, scale = FALSE)
mf_shadow(x = grid, col = "grey50", cex = 1, add = TRUE)
library("sf")
library("mapsf")
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
isere = st_union(communes)
library(cartogramR)
communes$pop2018inv = round(1/ communes$pop2018 * 1000000)
summmary(communes$pop2018inv)
summary(communes$pop2018inv)
data(usa)
carto1 <- cartogramR(usa, "electors64", options=list(verbose=1, L=256))
View(data)
View(usa)
test<- cartogramR(communes, count="pop2018", method="gsm", options=list(L=256, grid=TRUE, maxit = 5))
summary(communes$pop2018)
plot(communes$pop2018)
plot(communes$pop2018inv)
class(communes$pop2018)
class(communes$pop2018inv)
library("sf")
library("mapsf")
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
isere = st_union(communes)
grid = getGridLayer(x = communes, cellsize = 10000, type = "regular", var = "pop2018")
library("cartography")
grid = getGridLayer(x = communes, cellsize = 10000, type = "regular", var = "pop2018")
grid = getGridLayer(x = communes, cellsize = 100009, type = "regular", var = "pop2018")
getGridLayer
getgridlayer = function (x, cellsize, type = "regular", var, spdf, spdfid)
{
if (missing(x)) {
x <- sf::st_as_sf(spdf)
}
if (methods::is(x, "Spatial")) {
x <- sf::st_as_sf(x)
}
if (sum(missing(spdf), missing(spdfid)) != 2) {
stop("spdf and spdfid are defunct; use x instead.", call. = FALSE)
}
x$area <- sf::st_area(x)
if (type %in% c("regular", "hexagonal")) {
grid <- switch(type, regular = getGridAll(x, cellsize,
TRUE), hexagonal = getGridAll(x, cellsize, FALSE))
}
else {
stop("type should be either 'regular' or 'hexagonal'",
call. = FALSE)
}
gover <- sf::st_intersects(grid, x)
fun1 <- function(x) {
if (length(x) > 0) {
TRUE
}
else {
FALSE
}
}
grid <- grid[unlist(lapply(gover, FUN = fun1)), ]
options(warn = -1)
parts <- sf::st_intersection(x = grid[, "id_cell"], y = x)
options(warn = 0)
parts$area_part <- sf::st_area(parts)
lvar <- vector(mode = "list", length = length(var))
names(lvar) <- var
for (i in 1:length(lvar)) {
lvar[[i]] <- as.vector(parts[[names(lvar)[i]]] * parts$area_part/parts$area)
}
v <- aggregate(do.call(cbind, lvar), by = list(id = parts[["id_cell"]]),
FUN = sum, na.rm = TRUE)
l <- split(parts, parts[[1]])
a <- lapply(l, FUN = function(x) {
sf::st_buffer(sf::st_union(x), dist = 1e-07)
})
geometry <- sf::st_cast(do.call(c, a))
grid <- sf::st_sf(geometry, id = names(l))
grid$gridarea <- sf::st_area(x = grid)
grid <- merge(grid, v, by = "id", all.x = TRUE)
return(grid)
}
library("sf")
library("mapsf")
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
isere = st_union(communes)
getgridlayer = function (x, cellsize, type = "regular", var, spdf, spdfid)
{
if (missing(x)) {
x <- sf::st_as_sf(spdf)
}
if (methods::is(x, "Spatial")) {
x <- sf::st_as_sf(x)
}
if (sum(missing(spdf), missing(spdfid)) != 2) {
stop("spdf and spdfid are defunct; use x instead.", call. = FALSE)
}
x$area <- sf::st_area(x)
if (type %in% c("regular", "hexagonal")) {
grid <- switch(type, regular = getGridAll(x, cellsize,
TRUE), hexagonal = getGridAll(x, cellsize, FALSE))
}
else {
stop("type should be either 'regular' or 'hexagonal'",
call. = FALSE)
}
gover <- sf::st_intersects(grid, x)
fun1 <- function(x) {
if (length(x) > 0) {
TRUE
}
else {
FALSE
}
}
grid <- grid[unlist(lapply(gover, FUN = fun1)), ]
options(warn = -1)
parts <- sf::st_intersection(x = grid[, "id_cell"], y = x)
options(warn = 0)
parts$area_part <- sf::st_area(parts)
lvar <- vector(mode = "list", length = length(var))
names(lvar) <- var
for (i in 1:length(lvar)) {
lvar[[i]] <- as.vector(parts[[names(lvar)[i]]] * parts$area_part/parts$area)
}
v <- aggregate(do.call(cbind, lvar), by = list(id = parts[["id_cell"]]),
FUN = sum, na.rm = TRUE)
l <- split(parts, parts[[1]])
a <- lapply(l, FUN = function(x) {
sf::st_buffer(sf::st_union(x), dist = 1e-07)
})
geometry <- sf::st_cast(do.call(c, a))
grid <- sf::st_sf(geometry, id = names(l))
grid$gridarea <- sf::st_area(x = grid)
grid <- merge(grid, v, by = "id", all.x = TRUE)
return(grid)
}
gridpop2018 = getgridlayer(x = communes, cellsize = 10000, type = "regular", var = "pop2018")
library("sf")
library("mapsf")
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
isere = st_union(communes)
getgridlayer = function (x, cellsize, type = "regular", var, spdf, spdfid)
{
if (missing(x)) {
x <- sf::st_as_sf(spdf)
}
if (methods::is(x, "Spatial")) {
x <- sf::st_as_sf(x)
}
if (sum(missing(spdf), missing(spdfid)) != 2) {
stop("spdf and spdfid are defunct; use x instead.", call. = FALSE)
}
x$area <- sf::st_area(x)
if (type %in% c("regular", "hexagonal")) {
grid <- switch(type, regular = getGridAll(x, cellsize,
TRUE), hexagonal = getGridAll(x, cellsize, FALSE))
}
else {
stop("type should be either 'regular' or 'hexagonal'",
call. = FALSE)
}
gover <- sf::st_intersects(grid, x)
fun1 <- function(x) {
if (length(x) > 0) {
TRUE
}
else {
FALSE
}
}
grid <- grid[unlist(lapply(gover, FUN = fun1)), ]
options(warn = -1)
parts <- sf::st_intersection(x = grid[, "id_cell"], y = x)
options(warn = 0)
parts$area_part <- sf::st_area(parts)
lvar <- vector(mode = "list", length = length(var))
names(lvar) <- var
for (i in 1:length(lvar)) {
lvar[[i]] <- as.vector(parts[[names(lvar)[i]]] * parts$area_part/parts$area)
}
v <- aggregate(do.call(cbind, lvar), by = list(id = parts[["id_cell"]]),
FUN = sum, na.rm = TRUE)
l <- split(parts, parts[[1]])
a <- lapply(l, FUN = function(x) {
sf::st_buffer(sf::st_union(x), dist = 1e-07)
})
geometry <- sf::st_cast(do.call(c, a))
grid <- sf::st_sf(geometry, id = names(l))
grid$gridarea <- sf::st_area(x = grid)
grid <- merge(grid, v, by = "id", all.x = TRUE)
return(grid)
}
gridpop2018 = getgridlayer(x = communes, cellsize = 10000, type = "regular", var = "pop2018")
library(cartography)
gridpop2018 = getgridlayer(x = communes, cellsize = 10000, type = "regular", var = "pop2018")
library("sf")
library("mapsf")
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
isere = st_union(communes)
library(cartography)
gridpop2018 = getgridlayer(x = communes, cellsize = 10000, type = "regular", var = "pop2018")
library("sf")
library("mapsf")
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
grid = st_make_grid(communes, cellsize = 2000, square = FALSE)
plot(grid)
grid = st_make_grid(communes, cellsize = 2000, square = TRUE)
plot(grid)
grid = st_sf(id = c(1:length(grid)),geometry = grid)
View(grid)
grid = st_sf(id = c(1:length(grid)), geometry = grid)
grid = st_make_grid(communes, cellsize = 2000, square = TRUE)
grid = st_sf(id = c(1:length(grid)), geometry = grid)
ctr = st_centroid(grid)
i = 1
x = st_within(x = ctr[i,], y = cartogram, sparse = TRUE, prepared = TRUE)
x = st_within(x = ctr[i,], y = communes, sparse = TRUE, prepared = TRUE)
unlist(x)
i = 100
x = st_within(x = ctr[i,], y = communes, sparse = TRUE, prepared = TRUE)
unlist(x)
i = 1000
x = st_within(x = ctr[i,], y = communes, sparse = TRUE, prepared = TRUE)
unlist(x)
library("sf")
library("mapsf")
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
grid = st_make_grid(communes, cellsize = 2000, square = TRUE)
grid = st_sf(id = c(1:length(grid)), geometry = grid)
ids = communes[,"id"] %>% st_drop_geometry()
ctr = st_centroid(grid)
for(i in 1:nrow(grid)){
x = st_within(x = ctr[i,], y = cartogram, sparse = TRUE, prepared = TRUE)
id = ids[unlist(x),][1]
if (length(id) == 0){id = NA}
grid[i,"id"] = id
}
library("sf")
library("mapsf")
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
grid = st_make_grid(communes, cellsize = 2000, square = TRUE)
grid = st_sf(id = c(1:length(grid)), geometry = grid)
ids = communes[,"id"] %>% st_drop_geometry()
ctr = st_centroid(grid)
for(i in 1:nrow(grid)){
x = st_within(x = ctr[i,], y = communes, sparse = TRUE, prepared = TRUE)
id = ids[unlist(x),][1]
if (length(id) == 0){id = NA}
grid[i,"id"] = id
}
View(grid)
grid <- grid[!is.na(grid$id),]
View(grid)
for(i in 1:nrow(grid)){
grid[i,"pop"] = 0
}
View(grid)
i = 20
grid[i,"id"]
id = as.character(grid[i,"id"])
id
id = as.character(grid[i,"id"])[1]
id
id = as.character(grid[i,"id"])[1]
i = 20
id = as.character(grid[i,"id"])[1]
communes[communes$id == id,]
communes[communes$id == id,"pop2018"]
as.numeriec(communes[communes$id == id,"pop2018"])
communes[communes$id == id,"pop2018"] %>% st_drop_geometry()
as.numeric(communes[communes$id == id,"pop2018"] %>% st_drop_geometry())
count = grid[grid$id == id,]
count
count = nrow(grid[grid$id == id,])
count
for(i in 1:nrow(grid)){
id = as.character(grid[i,"id"])[1]
popAll = as.numeric(communes[communes$id == id,"pop2018"] %>% st_drop_geometry())
count = nrow(grid[grid$id == id,])
grid[i,"pop"] = popAll / count
}
View(grid)
mf_map(communes, col = "#CCCCCC", border = "white", lwd = 0.5, add = FALSE)
mf_map(grid, var = "pop", col = "red", border = "#6b4266", type = "prop",
inches = 0.8, leg_title_cex = 1.2, leg_val_cex	= 0.8,
leg_title = "Nombre d'habitants, 2018")
mf_map(communes, col = "#CCCCCC", border = "white", lwd = 0.5, add = FALSE)
mf_map(grid, var = "pop", col = "red", border = "#6b4266", type = "prop",
inches = 0.2, leg_title_cex = 1.2, leg_val_cex	= 0.8,
leg_title = "Nombre d'habitants, 2018")
mf_map(communes, col = "#CCCCCC", border = "white", lwd = 0.5, add = FALSE)
mf_map(grid, var = "pop", col = "red", border = "#6b4266", type = "prop",
inches = 0.1, leg_title_cex = 1.2, leg_val_cex	= 0.8,
leg_title = "Nombre d'habitants, 2018")
library("sf")
library("mapsf")
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
grid = st_make_grid(communes, cellsize = 1000, square = TRUE)
grid = st_sf(id = c(1:length(grid)), geometry = grid)
ids = communes[,"id"] %>% st_drop_geometry()
ctr = st_centroid(grid)
for(i in 1:nrow(grid)){
x = st_within(x = ctr[i,], y = communes, sparse = TRUE, prepared = TRUE)
id = ids[unlist(x),][1]
if (length(id) == 0){id = NA}
grid[i,"id"] = id
}
grid <- grid[!is.na(grid$id),]
for(i in 1:nrow(grid)){
id = as.character(grid[i,"id"])[1]
popAll = as.numeric(communes[communes$id == id,"pop2018"] %>% st_drop_geometry())
count = nrow(grid[grid$id == id,])
grid[i,"pop"] = popAll / count
}
st_write(grid,"files/grid.gpkg", delete_layer=TRUE)
if(!file.exists("files/grid.gpkg")){
for(i in 1:nrow(grid)){
x = st_within(x = ctr[i,], y = communes, sparse = TRUE, prepared = TRUE)
id = ids[unlist(x),][1]
if (length(id) == 0){id = NA}
grid[i,"id"] = id
}
grid <- grid[!is.na(grid$id),]
for(i in 1:nrow(grid)){
id = as.character(grid[i,"id"])[1]
popAll = as.numeric(communes[communes$id == id,"pop2018"] %>% st_drop_geometry())
count = nrow(grid[grid$id == id,])
grid[i,"pop"] = popAll / count
}
st_write(grid,"files/grid.gpkg", delete_layer=TRUE)
} else {
grid = st_readd("files/grid.gpk")
}
if(!file.exists("files/grid.gpkg")){
for(i in 1:nrow(grid)){
x = st_within(x = ctr[i,], y = communes, sparse = TRUE, prepared = TRUE)
id = ids[unlist(x),][1]
if (length(id) == 0){id = NA}
grid[i,"id"] = id
}
grid <- grid[!is.na(grid$id),]
for(i in 1:nrow(grid)){
id = as.character(grid[i,"id"])[1]
popAll = as.numeric(communes[communes$id == id,"pop2018"] %>% st_drop_geometry())
count = nrow(grid[grid$id == id,])
grid[i,"pop"] = popAll / count
}
st_write(grid,"files/grid.gpkg", delete_layer=TRUE)
} else {
grid = st_readd("files/grid.gpk")
}
if(!file.exists("files/grid.gpkg")){
for(i in 1:nrow(grid)){
x = st_within(x = ctr[i,], y = communes, sparse = TRUE, prepared = TRUE)
id = ids[unlist(x),][1]
if (length(id) == 0){id = NA}
grid[i,"id"] = id
}
grid <- grid[!is.na(grid$id),]
for(i in 1:nrow(grid)){
id = as.character(grid[i,"id"])[1]
popAll = as.numeric(communes[communes$id == id,"pop2018"] %>% st_drop_geometry())
count = nrow(grid[grid$id == id,])
grid[i,"pop"] = popAll / count
}
st_write(grid,"files/grid.gpkg", delete_layer=TRUE)
} else {
grid = st_readd("files/grid.gpk")
}
if(!file.exists("files/grid.gpkg")){
for(i in 1:nrow(grid)){
x = st_within(x = ctr[i,], y = communes, sparse = TRUE, prepared = TRUE)
id = ids[unlist(x),][1]
if (length(id) == 0){id = NA}
grid[i,"id"] = id
}
grid <- grid[!is.na(grid$id),]
for(i in 1:nrow(grid)){
id = as.character(grid[i,"id"])[1]
popAll = as.numeric(communes[communes$id == id,"pop2018"] %>% st_drop_geometry())
count = nrow(grid[grid$id == id,])
grid[i,"pop"] = popAll / count
}
st_write(grid,"files/grid.gpkg", delete_layer=TRUE)
} else {
grid = st_read("files/grid.gpk")
}
if(!file.exists("files/grid.gpkg")){
for(i in 1:nrow(grid)){
x = st_within(x = ctr[i,], y = communes, sparse = TRUE, prepared = TRUE)
id = ids[unlist(x),][1]
if (length(id) == 0){id = NA}
grid[i,"id"] = id
}
grid <- grid[!is.na(grid$id),]
for(i in 1:nrow(grid)){
id = as.character(grid[i,"id"])[1]
popAll = as.numeric(communes[communes$id == id,"pop2018"] %>% st_drop_geometry())
count = nrow(grid[grid$id == id,])
grid[i,"pop"] = popAll / count
}
st_write(grid,"files/grid.gpkg", delete_layer=TRUE)
} else {
grid = st_read("files/grid.gpkg")
}
if(!file.exists("files/grid.gpkg")){
grid = st_make_grid(communes, cellsize = 1000, square = TRUE)
grid = st_sf(id = c(1:length(grid)), geometry = grid)
ids = communes[,"id"] %>% st_drop_geometry()
ctr = st_centroid(grid)
for(i in 1:nrow(grid)){
x = st_within(x = ctr[i,], y = communes, sparse = TRUE, prepared = TRUE)
id = ids[unlist(x),][1]
if (length(id) == 0){id = NA}
grid[i,"id"] = id
}
grid <- grid[!is.na(grid$id),]
for(i in 1:nrow(grid)){
id = as.character(grid[i,"id"])[1]
popAll = as.numeric(communes[communes$id == id,"pop2018"] %>% st_drop_geometry())
count = nrow(grid[grid$id == id,])
grid[i,"pop"] = popAll / count
}
st_write(grid,"files/grid.gpkg", delete_layer=TRUE)
} else {
grid = st_read("files/grid.gpkg")
}
View(grid)
mf_map(communes, col = "#CCCCCC", border = "white", lwd = 0.5, add = FALSE)
mf_map(grid, var = "pop", col = "red", border = "#6b4266", type = "prop",
inches = 0.1, leg_title_cex = 1.2, leg_val_cex	= 0.8,
leg_title = "Nombre d'habitants, 2018")
mf_map(communes, col = "#CCCCCC", border = "white", lwd = 0.5, add = FALSE)
mf_map(grid, var = "pop", col = "red", border = "#6b4266", type = "prop",
inches = 0.05, leg_title_cex = 1.2, leg_val_cex	= 0.8,
leg_title = "Nombre d'habitants, 2018")
library(sf)
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
library(sf)
communes <- st_read("data/isere.geojson", quiet = TRUE ) %>% st_transform(2154)
data <- read.csv("data/popisrere.csv",  dec = ",")
communes = merge(x = communes[,c("id","name","geometry")],
y = data[,c("id", "pop2018","agri", "art", "cadr", "interm", "emp","ouvr","retr")],
by = "id")
isere = st_union(communes)
library(recmap)
coords <- st_centroid(communes)
coords <- st_transform(coords, crs="+proj=longlat +datum=WGS84 +ellps=WGS84")
coords <- sfc_as_cols(coords)
